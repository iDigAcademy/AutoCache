name: Release on Push to Main

on:
  push:
    branches:
      - main  # Only trigger on pushes to main; ignores development and other branches

permissions:
  contents: write  # Required for tagging and releasing

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed to fetch full commit history for release notes

      - name: Get latest tag
        id: get_latest_tag
        run: |
          # Get the latest tag, or default to 0.0.0 if no tags exist
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT
          echo "Latest tag: $latest_tag"

      - name: Determine version bump
        id: version_bump
        run: |
          # Get the commit message
          commit_message=$(git log -1 --pretty=%B)
          echo "Commit message: $commit_message"
          
          # Default to patch bump
          bump_type="patch"
          
          # Check for version bump indicators in commit message
          if echo "$commit_message" | grep -iqE '\[(major|breaking)\]'; then
            bump_type="major"
          elif echo "$commit_message" | grep -iqE '\[(minor|feature)\]'; then
            bump_type="minor"
          fi
          
          echo "bump_type=$bump_type" >> $GITHUB_OUTPUT
          echo "Version bump type: $bump_type"

      - name: Calculate new version
        id: new_version
        run: |
          latest_tag="${{ steps.get_latest_tag.outputs.latest_tag }}"
          bump_type="${{ steps.version_bump.outputs.bump_type }}"
          
          # Parse current version (remove 'v' prefix if present)
          version=${latest_tag#v}
          
          # Split version into major.minor.patch
          IFS='.' read -r major minor patch <<< "$version"
          
          # Ensure numeric values (default to 0 if empty)
          major=${major:-0}
          minor=${minor:-0}
          patch=${patch:-0}
          
          # Calculate new version based on bump type
          case $bump_type in
            "major")
              new_major=$((major + 1))
              new_minor=0
              new_patch=0
              ;;
            "minor")
              new_major=$major
              new_minor=$((minor + 1))
              new_patch=0
              ;;
            "patch")
              new_major=$major
              new_minor=$minor
              new_patch=$((patch + 1))
              ;;
          esac
          
          new_version="$new_major.$new_minor.$new_patch"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT
          echo "New version: $new_version"

      - name: Create tag
        run: |
          new_version="${{ steps.new_version.outputs.new_version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "v$new_version" -m "Release v$new_version"
          git push origin "v$new_version"

      - name: Create release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          new_version="${{ steps.new_version.outputs.new_version }}"
          commit_message=$(git log -1 --pretty=%B)
          
          # Generate release notes
          release_notes="## Release v$new_version"$'\n\n'"### Changes"$'\n'"- $commit_message"
          
          # Create release using GitHub CLI
          gh release create "v$new_version" \
            --title "Release v$new_version" \
            --notes "$release_notes" \
            --latest